// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  admin: (where?: AdminWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  invoice: (where?: InvoiceWhereInput) => Promise<boolean>;
  note: (where?: NoteWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  test: (where?: TestWhereInput) => Promise<boolean>;
  tutor: (where?: TutorWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  admin: (where: AdminWhereUniqueInput) => AdminNullablePromise;
  admins: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Admin>;
  adminsConnection: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdminConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  invoice: (where: InvoiceWhereUniqueInput) => InvoiceNullablePromise;
  invoices: (args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invoice>;
  invoicesConnection: (args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvoiceConnectionPromise;
  note: (where: NoteWhereUniqueInput) => NoteNullablePromise;
  notes: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Note>;
  notesConnection: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NoteConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionNullablePromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentNullablePromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  test: (where: TestWhereUniqueInput) => TestNullablePromise;
  tests: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Test>;
  testsConnection: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestConnectionPromise;
  tutor: (where: TutorWhereUniqueInput) => TutorNullablePromise;
  tutors: (args?: {
    where?: TutorWhereInput;
    orderBy?: TutorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tutor>;
  tutorsConnection: (args?: {
    where?: TutorWhereInput;
    orderBy?: TutorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TutorConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdmin: (data: AdminCreateInput) => AdminPromise;
  updateAdmin: (args: {
    data: AdminUpdateInput;
    where: AdminWhereUniqueInput;
  }) => AdminPromise;
  updateManyAdmins: (args: {
    data: AdminUpdateManyMutationInput;
    where?: AdminWhereInput;
  }) => BatchPayloadPromise;
  upsertAdmin: (args: {
    where: AdminWhereUniqueInput;
    create: AdminCreateInput;
    update: AdminUpdateInput;
  }) => AdminPromise;
  deleteAdmin: (where: AdminWhereUniqueInput) => AdminPromise;
  deleteManyAdmins: (where?: AdminWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createInvoice: (data: InvoiceCreateInput) => InvoicePromise;
  updateInvoice: (args: {
    data: InvoiceUpdateInput;
    where: InvoiceWhereUniqueInput;
  }) => InvoicePromise;
  updateManyInvoices: (args: {
    data: InvoiceUpdateManyMutationInput;
    where?: InvoiceWhereInput;
  }) => BatchPayloadPromise;
  upsertInvoice: (args: {
    where: InvoiceWhereUniqueInput;
    create: InvoiceCreateInput;
    update: InvoiceUpdateInput;
  }) => InvoicePromise;
  deleteInvoice: (where: InvoiceWhereUniqueInput) => InvoicePromise;
  deleteManyInvoices: (where?: InvoiceWhereInput) => BatchPayloadPromise;
  createNote: (data: NoteCreateInput) => NotePromise;
  updateNote: (args: {
    data: NoteUpdateInput;
    where: NoteWhereUniqueInput;
  }) => NotePromise;
  updateManyNotes: (args: {
    data: NoteUpdateManyMutationInput;
    where?: NoteWhereInput;
  }) => BatchPayloadPromise;
  upsertNote: (args: {
    where: NoteWhereUniqueInput;
    create: NoteCreateInput;
    update: NoteUpdateInput;
  }) => NotePromise;
  deleteNote: (where: NoteWhereUniqueInput) => NotePromise;
  deleteManyNotes: (where?: NoteWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  updateManySessions: (args: {
    data: SessionUpdateManyMutationInput;
    where?: SessionWhereInput;
  }) => BatchPayloadPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createTest: (data: TestCreateInput) => TestPromise;
  updateTest: (args: {
    data: TestUpdateInput;
    where: TestWhereUniqueInput;
  }) => TestPromise;
  updateManyTests: (args: {
    data: TestUpdateManyMutationInput;
    where?: TestWhereInput;
  }) => BatchPayloadPromise;
  upsertTest: (args: {
    where: TestWhereUniqueInput;
    create: TestCreateInput;
    update: TestUpdateInput;
  }) => TestPromise;
  deleteTest: (where: TestWhereUniqueInput) => TestPromise;
  deleteManyTests: (where?: TestWhereInput) => BatchPayloadPromise;
  createTutor: (data: TutorCreateInput) => TutorPromise;
  updateTutor: (args: {
    data: TutorUpdateInput;
    where: TutorWhereUniqueInput;
  }) => TutorPromise;
  updateManyTutors: (args: {
    data: TutorUpdateManyMutationInput;
    where?: TutorWhereInput;
  }) => BatchPayloadPromise;
  upsertTutor: (args: {
    where: TutorWhereUniqueInput;
    create: TutorCreateInput;
    update: TutorUpdateInput;
  }) => TutorPromise;
  deleteTutor: (where: TutorWhereUniqueInput) => TutorPromise;
  deleteManyTutors: (where?: TutorWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  admin: (
    where?: AdminSubscriptionWhereInput
  ) => AdminSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  invoice: (
    where?: InvoiceSubscriptionWhereInput
  ) => InvoiceSubscriptionPayloadSubscription;
  note: (
    where?: NoteSubscriptionWhereInput
  ) => NoteSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  test: (
    where?: TestSubscriptionWhereInput
  ) => TestSubscriptionPayloadSubscription;
  tutor: (
    where?: TutorSubscriptionWhereInput
  ) => TutorSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AdminOrderByInput =
  | "idadmin_ASC"
  | "idadmin_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type CompanyOrderByInput =
  | "idcompany_ASC"
  | "idcompany_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC";

export type InvoiceOrderByInput =
  | "idinvoice_ASC"
  | "idinvoice_DESC"
  | "date_ASC"
  | "date_DESC"
  | "tutorpaid_ASC"
  | "tutorpaid_DESC"
  | "studentpaid_ASC"
  | "studentpaid_DESC";

export type NoteOrderByInput =
  | "idnote_ASC"
  | "idnote_DESC"
  | "text_ASC"
  | "text_DESC";

export type ProductOrderByInput =
  | "idproduct_ASC"
  | "idproduct_DESC"
  | "active_ASC"
  | "active_DESC"
  | "rate_ASC"
  | "rate_DESC"
  | "tutorshare_ASC"
  | "tutorshare_DESC"
  | "subject_ASC"
  | "subject_DESC";

export type SessionOrderByInput =
  | "idsession_ASC"
  | "idsession_DESC"
  | "date_ASC"
  | "date_DESC"
  | "length_ASC"
  | "length_DESC"
  | "location_ASC"
  | "location_DESC"
  | "studentconfirmed_ASC"
  | "studentconfirmed_DESC"
  | "tutorconfirmed_ASC"
  | "tutorconfirmed_DESC"
  | "invoiced_ASC"
  | "invoiced_DESC";

export type StudentOrderByInput =
  | "idstudent_ASC"
  | "idstudent_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type TestOrderByInput =
  | "idtest_ASC"
  | "idtest_DESC"
  | "str_ASC"
  | "str_DESC";

export type TutorOrderByInput =
  | "idtutor_ASC"
  | "idtutor_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type UserOrderByInput =
  | "iduser_ASC"
  | "iduser_DESC"
  | "email_ASC"
  | "email_DESC"
  | "role_ASC"
  | "role_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AdminWhereUniqueInput = AtLeastOne<{
  idadmin: Maybe<Int>;
}>;

export interface AdminWhereInput {
  idadmin?: Maybe<Int>;
  idadmin_not?: Maybe<Int>;
  idadmin_in?: Maybe<Int[] | Int>;
  idadmin_not_in?: Maybe<Int[] | Int>;
  idadmin_lt?: Maybe<Int>;
  idadmin_lte?: Maybe<Int>;
  idadmin_gt?: Maybe<Int>;
  idadmin_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<AdminWhereInput[] | AdminWhereInput>;
  OR?: Maybe<AdminWhereInput[] | AdminWhereInput>;
  NOT?: Maybe<AdminWhereInput[] | AdminWhereInput>;
}

export interface UserWhereInput {
  iduser?: Maybe<Int>;
  iduser_not?: Maybe<Int>;
  iduser_in?: Maybe<Int[] | Int>;
  iduser_not_in?: Maybe<Int[] | Int>;
  iduser_lt?: Maybe<Int>;
  iduser_lte?: Maybe<Int>;
  iduser_gt?: Maybe<Int>;
  iduser_gte?: Maybe<Int>;
  company?: Maybe<CompanyWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<String>;
  role_not?: Maybe<String>;
  role_in?: Maybe<String[] | String>;
  role_not_in?: Maybe<String[] | String>;
  role_lt?: Maybe<String>;
  role_lte?: Maybe<String>;
  role_gt?: Maybe<String>;
  role_gte?: Maybe<String>;
  role_contains?: Maybe<String>;
  role_not_contains?: Maybe<String>;
  role_starts_with?: Maybe<String>;
  role_not_starts_with?: Maybe<String>;
  role_ends_with?: Maybe<String>;
  role_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CompanyWhereInput {
  idcompany?: Maybe<Int>;
  idcompany_not?: Maybe<Int>;
  idcompany_in?: Maybe<Int[] | Int>;
  idcompany_not_in?: Maybe<Int[] | Int>;
  idcompany_lt?: Maybe<Int>;
  idcompany_lte?: Maybe<Int>;
  idcompany_gt?: Maybe<Int>;
  idcompany_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  idcompany: Maybe<Int>;
}>;

export type InvoiceWhereUniqueInput = AtLeastOne<{
  idinvoice: Maybe<Int>;
}>;

export interface InvoiceWhereInput {
  idinvoice?: Maybe<Int>;
  idinvoice_not?: Maybe<Int>;
  idinvoice_in?: Maybe<Int[] | Int>;
  idinvoice_not_in?: Maybe<Int[] | Int>;
  idinvoice_lt?: Maybe<Int>;
  idinvoice_lte?: Maybe<Int>;
  idinvoice_gt?: Maybe<Int>;
  idinvoice_gte?: Maybe<Int>;
  session?: Maybe<SessionWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  tutorpaid?: Maybe<Boolean>;
  tutorpaid_not?: Maybe<Boolean>;
  studentpaid?: Maybe<Boolean>;
  studentpaid_not?: Maybe<Boolean>;
  note?: Maybe<NoteWhereInput>;
  AND?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
  OR?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
  NOT?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
}

export interface SessionWhereInput {
  idsession?: Maybe<Int>;
  idsession_not?: Maybe<Int>;
  idsession_in?: Maybe<Int[] | Int>;
  idsession_not_in?: Maybe<Int[] | Int>;
  idsession_lt?: Maybe<Int>;
  idsession_lte?: Maybe<Int>;
  idsession_gt?: Maybe<Int>;
  idsession_gte?: Maybe<Int>;
  product?: Maybe<ProductWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  length?: Maybe<Float>;
  length_not?: Maybe<Float>;
  length_in?: Maybe<Float[] | Float>;
  length_not_in?: Maybe<Float[] | Float>;
  length_lt?: Maybe<Float>;
  length_lte?: Maybe<Float>;
  length_gt?: Maybe<Float>;
  length_gte?: Maybe<Float>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  studentconfirmed?: Maybe<Boolean>;
  studentconfirmed_not?: Maybe<Boolean>;
  tutorconfirmed?: Maybe<Boolean>;
  tutorconfirmed_not?: Maybe<Boolean>;
  invoiced?: Maybe<Boolean>;
  invoiced_not?: Maybe<Boolean>;
  note?: Maybe<NoteWhereInput>;
  studentnote?: Maybe<NoteWhereInput>;
  tutornote?: Maybe<NoteWhereInput>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  OR?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  NOT?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface ProductWhereInput {
  idproduct?: Maybe<Int>;
  idproduct_not?: Maybe<Int>;
  idproduct_in?: Maybe<Int[] | Int>;
  idproduct_not_in?: Maybe<Int[] | Int>;
  idproduct_lt?: Maybe<Int>;
  idproduct_lte?: Maybe<Int>;
  idproduct_gt?: Maybe<Int>;
  idproduct_gte?: Maybe<Int>;
  student?: Maybe<StudentWhereInput>;
  tutor?: Maybe<TutorWhereInput>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  company?: Maybe<CompanyWhereInput>;
  rate?: Maybe<Float>;
  rate_not?: Maybe<Float>;
  rate_in?: Maybe<Float[] | Float>;
  rate_not_in?: Maybe<Float[] | Float>;
  rate_lt?: Maybe<Float>;
  rate_lte?: Maybe<Float>;
  rate_gt?: Maybe<Float>;
  rate_gte?: Maybe<Float>;
  tutorshare?: Maybe<Float>;
  tutorshare_not?: Maybe<Float>;
  tutorshare_in?: Maybe<Float[] | Float>;
  tutorshare_not_in?: Maybe<Float[] | Float>;
  tutorshare_lt?: Maybe<Float>;
  tutorshare_lte?: Maybe<Float>;
  tutorshare_gt?: Maybe<Float>;
  tutorshare_gte?: Maybe<Float>;
  subject?: Maybe<String>;
  subject_not?: Maybe<String>;
  subject_in?: Maybe<String[] | String>;
  subject_not_in?: Maybe<String[] | String>;
  subject_lt?: Maybe<String>;
  subject_lte?: Maybe<String>;
  subject_gt?: Maybe<String>;
  subject_gte?: Maybe<String>;
  subject_contains?: Maybe<String>;
  subject_not_contains?: Maybe<String>;
  subject_starts_with?: Maybe<String>;
  subject_not_starts_with?: Maybe<String>;
  subject_ends_with?: Maybe<String>;
  subject_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface StudentWhereInput {
  idstudent?: Maybe<Int>;
  idstudent_not?: Maybe<Int>;
  idstudent_in?: Maybe<Int[] | Int>;
  idstudent_not_in?: Maybe<Int[] | Int>;
  idstudent_lt?: Maybe<Int>;
  idstudent_lte?: Maybe<Int>;
  idstudent_gt?: Maybe<Int>;
  idstudent_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  OR?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  NOT?: Maybe<StudentWhereInput[] | StudentWhereInput>;
}

export interface TutorWhereInput {
  idtutor?: Maybe<Int>;
  idtutor_not?: Maybe<Int>;
  idtutor_in?: Maybe<Int[] | Int>;
  idtutor_not_in?: Maybe<Int[] | Int>;
  idtutor_lt?: Maybe<Int>;
  idtutor_lte?: Maybe<Int>;
  idtutor_gt?: Maybe<Int>;
  idtutor_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<TutorWhereInput[] | TutorWhereInput>;
  OR?: Maybe<TutorWhereInput[] | TutorWhereInput>;
  NOT?: Maybe<TutorWhereInput[] | TutorWhereInput>;
}

export interface NoteWhereInput {
  idnote?: Maybe<Int>;
  idnote_not?: Maybe<Int>;
  idnote_in?: Maybe<Int[] | Int>;
  idnote_not_in?: Maybe<Int[] | Int>;
  idnote_lt?: Maybe<Int>;
  idnote_lte?: Maybe<Int>;
  idnote_gt?: Maybe<Int>;
  idnote_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  OR?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  NOT?: Maybe<NoteWhereInput[] | NoteWhereInput>;
}

export type NoteWhereUniqueInput = AtLeastOne<{
  idnote: Maybe<Int>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  idproduct: Maybe<Int>;
}>;

export type SessionWhereUniqueInput = AtLeastOne<{
  idsession: Maybe<Int>;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  idstudent: Maybe<Int>;
}>;

export type TestWhereUniqueInput = AtLeastOne<{
  idtest: Maybe<Int>;
}>;

export interface TestWhereInput {
  idtest?: Maybe<Int>;
  idtest_not?: Maybe<Int>;
  idtest_in?: Maybe<Int[] | Int>;
  idtest_not_in?: Maybe<Int[] | Int>;
  idtest_lt?: Maybe<Int>;
  idtest_lte?: Maybe<Int>;
  idtest_gt?: Maybe<Int>;
  idtest_gte?: Maybe<Int>;
  student?: Maybe<StudentWhereInput>;
  str?: Maybe<String>;
  str_not?: Maybe<String>;
  str_in?: Maybe<String[] | String>;
  str_not_in?: Maybe<String[] | String>;
  str_lt?: Maybe<String>;
  str_lte?: Maybe<String>;
  str_gt?: Maybe<String>;
  str_gte?: Maybe<String>;
  str_contains?: Maybe<String>;
  str_not_contains?: Maybe<String>;
  str_starts_with?: Maybe<String>;
  str_not_starts_with?: Maybe<String>;
  str_ends_with?: Maybe<String>;
  str_not_ends_with?: Maybe<String>;
  AND?: Maybe<TestWhereInput[] | TestWhereInput>;
  OR?: Maybe<TestWhereInput[] | TestWhereInput>;
  NOT?: Maybe<TestWhereInput[] | TestWhereInput>;
}

export type TutorWhereUniqueInput = AtLeastOne<{
  idtutor: Maybe<Int>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  iduser: Maybe<Int>;
  email?: Maybe<String>;
}>;

export interface AdminCreateInput {
  idadmin?: Maybe<Int>;
  name: String;
  phone: String;
  user: UserCreateOneInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  iduser?: Maybe<Int>;
  company: CompanyCreateOneInput;
  email: String;
  role: String;
}

export interface CompanyCreateOneInput {
  create?: Maybe<CompanyCreateInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateInput {
  idcompany?: Maybe<Int>;
  name: String;
  address?: Maybe<String>;
}

export interface AdminUpdateInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  email?: Maybe<String>;
  role?: Maybe<String>;
}

export interface CompanyUpdateOneRequiredInput {
  create?: Maybe<CompanyCreateInput>;
  update?: Maybe<CompanyUpdateDataInput>;
  upsert?: Maybe<CompanyUpsertNestedInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface AdminUpdateManyMutationInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface CompanyUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface InvoiceCreateInput {
  idinvoice?: Maybe<Int>;
  session: SessionCreateOneInput;
  tutorpaid?: Maybe<Boolean>;
  studentpaid?: Maybe<Boolean>;
  note?: Maybe<NoteCreateOneInput>;
}

export interface SessionCreateOneInput {
  create?: Maybe<SessionCreateInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionCreateInput {
  idsession?: Maybe<Int>;
  product: ProductCreateOneInput;
  date: DateTimeInput;
  length: Float;
  location: String;
  studentconfirmed?: Maybe<Boolean>;
  tutorconfirmed?: Maybe<Boolean>;
  invoiced?: Maybe<Boolean>;
  note?: Maybe<NoteCreateOneInput>;
  studentnote?: Maybe<NoteCreateOneInput>;
  tutornote?: Maybe<NoteCreateOneInput>;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductCreateInput {
  idproduct?: Maybe<Int>;
  student: StudentCreateOneInput;
  tutor: TutorCreateOneInput;
  active?: Maybe<Boolean>;
  company: CompanyCreateOneInput;
  rate: Float;
  tutorshare: Float;
  subject: String;
}

export interface StudentCreateOneInput {
  create?: Maybe<StudentCreateInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface StudentCreateInput {
  idstudent?: Maybe<Int>;
  name: String;
  phone: String;
  user?: Maybe<UserCreateOneInput>;
}

export interface TutorCreateOneInput {
  create?: Maybe<TutorCreateInput>;
  connect?: Maybe<TutorWhereUniqueInput>;
}

export interface TutorCreateInput {
  idtutor?: Maybe<Int>;
  name: String;
  phone: String;
  user: UserCreateOneInput;
}

export interface NoteCreateOneInput {
  create?: Maybe<NoteCreateInput>;
  connect?: Maybe<NoteWhereUniqueInput>;
}

export interface NoteCreateInput {
  idnote?: Maybe<Int>;
  user: UserCreateOneInput;
  text: String;
}

export interface InvoiceUpdateInput {
  session?: Maybe<SessionUpdateOneRequiredInput>;
  tutorpaid?: Maybe<Boolean>;
  studentpaid?: Maybe<Boolean>;
  note?: Maybe<NoteUpdateOneInput>;
}

export interface SessionUpdateOneRequiredInput {
  create?: Maybe<SessionCreateInput>;
  update?: Maybe<SessionUpdateDataInput>;
  upsert?: Maybe<SessionUpsertNestedInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionUpdateDataInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  date?: Maybe<DateTimeInput>;
  length?: Maybe<Float>;
  location?: Maybe<String>;
  studentconfirmed?: Maybe<Boolean>;
  tutorconfirmed?: Maybe<Boolean>;
  invoiced?: Maybe<Boolean>;
  note?: Maybe<NoteUpdateOneInput>;
  studentnote?: Maybe<NoteUpdateOneInput>;
  tutornote?: Maybe<NoteUpdateOneInput>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductUpdateDataInput {
  student?: Maybe<StudentUpdateOneRequiredInput>;
  tutor?: Maybe<TutorUpdateOneRequiredInput>;
  active?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  rate?: Maybe<Float>;
  tutorshare?: Maybe<Float>;
  subject?: Maybe<String>;
}

export interface StudentUpdateOneRequiredInput {
  create?: Maybe<StudentCreateInput>;
  update?: Maybe<StudentUpdateDataInput>;
  upsert?: Maybe<StudentUpsertNestedInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface StudentUpdateDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface StudentUpsertNestedInput {
  update: StudentUpdateDataInput;
  create: StudentCreateInput;
}

export interface TutorUpdateOneRequiredInput {
  create?: Maybe<TutorCreateInput>;
  update?: Maybe<TutorUpdateDataInput>;
  upsert?: Maybe<TutorUpsertNestedInput>;
  connect?: Maybe<TutorWhereUniqueInput>;
}

export interface TutorUpdateDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TutorUpsertNestedInput {
  update: TutorUpdateDataInput;
  create: TutorCreateInput;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface NoteUpdateOneInput {
  create?: Maybe<NoteCreateInput>;
  update?: Maybe<NoteUpdateDataInput>;
  upsert?: Maybe<NoteUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NoteWhereUniqueInput>;
}

export interface NoteUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  text?: Maybe<String>;
}

export interface NoteUpsertNestedInput {
  update: NoteUpdateDataInput;
  create: NoteCreateInput;
}

export interface SessionUpsertNestedInput {
  update: SessionUpdateDataInput;
  create: SessionCreateInput;
}

export interface InvoiceUpdateManyMutationInput {
  tutorpaid?: Maybe<Boolean>;
  studentpaid?: Maybe<Boolean>;
}

export interface NoteUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  text?: Maybe<String>;
}

export interface NoteUpdateManyMutationInput {
  text?: Maybe<String>;
}

export interface ProductUpdateInput {
  student?: Maybe<StudentUpdateOneRequiredInput>;
  tutor?: Maybe<TutorUpdateOneRequiredInput>;
  active?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  rate?: Maybe<Float>;
  tutorshare?: Maybe<Float>;
  subject?: Maybe<String>;
}

export interface ProductUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  rate?: Maybe<Float>;
  tutorshare?: Maybe<Float>;
  subject?: Maybe<String>;
}

export interface SessionUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  date?: Maybe<DateTimeInput>;
  length?: Maybe<Float>;
  location?: Maybe<String>;
  studentconfirmed?: Maybe<Boolean>;
  tutorconfirmed?: Maybe<Boolean>;
  invoiced?: Maybe<Boolean>;
  note?: Maybe<NoteUpdateOneInput>;
  studentnote?: Maybe<NoteUpdateOneInput>;
  tutornote?: Maybe<NoteUpdateOneInput>;
}

export interface SessionUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  length?: Maybe<Float>;
  location?: Maybe<String>;
  studentconfirmed?: Maybe<Boolean>;
  tutorconfirmed?: Maybe<Boolean>;
  invoiced?: Maybe<Boolean>;
}

export interface StudentUpdateInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface StudentUpdateManyMutationInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface TestCreateInput {
  idtest?: Maybe<Int>;
  student: StudentCreateOneInput;
  str?: Maybe<String>;
}

export interface TestUpdateInput {
  student?: Maybe<StudentUpdateOneRequiredInput>;
  str?: Maybe<String>;
}

export interface TestUpdateManyMutationInput {
  str?: Maybe<String>;
}

export interface TutorUpdateInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TutorUpdateManyMutationInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface UserUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  email?: Maybe<String>;
  role?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  role?: Maybe<String>;
}

export interface AdminSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AdminWhereInput>;
  AND?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
  OR?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
  NOT?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface InvoiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InvoiceWhereInput>;
  AND?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
  OR?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
  NOT?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
}

export interface NoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NoteWhereInput>;
  AND?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  OR?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  NOT?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  OR?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  NOT?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudentWhereInput>;
  AND?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  OR?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  NOT?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
}

export interface TestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TestWhereInput>;
  AND?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
  OR?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
  NOT?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
}

export interface TutorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TutorWhereInput>;
  AND?: Maybe<TutorSubscriptionWhereInput[] | TutorSubscriptionWhereInput>;
  OR?: Maybe<TutorSubscriptionWhereInput[] | TutorSubscriptionWhereInput>;
  NOT?: Maybe<TutorSubscriptionWhereInput[] | TutorSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Admin {
  idadmin: Int;
  name: String;
  phone: String;
}

export interface AdminPromise extends Promise<Admin>, Fragmentable {
  idadmin: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface AdminSubscription
  extends Promise<AsyncIterator<Admin>>,
    Fragmentable {
  idadmin: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface AdminNullablePromise
  extends Promise<Admin | null>,
    Fragmentable {
  idadmin: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface User {
  iduser: Int;
  email: String;
  role: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  iduser: () => Promise<Int>;
  company: <T = CompanyPromise>() => T;
  email: () => Promise<String>;
  role: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  iduser: () => Promise<AsyncIterator<Int>>;
  company: <T = CompanySubscription>() => T;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  iduser: () => Promise<Int>;
  company: <T = CompanyPromise>() => T;
  email: () => Promise<String>;
  role: () => Promise<String>;
}

export interface Company {
  idcompany: Int;
  name: String;
  address?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  idcompany: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  idcompany: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  idcompany: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface AdminConnection {
  pageInfo: PageInfo;
  edges: AdminEdge[];
}

export interface AdminConnectionPromise
  extends Promise<AdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdminEdge>>() => T;
  aggregate: <T = AggregateAdminPromise>() => T;
}

export interface AdminConnectionSubscription
  extends Promise<AsyncIterator<AdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdminSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AdminEdge {
  node: Admin;
  cursor: String;
}

export interface AdminEdgePromise extends Promise<AdminEdge>, Fragmentable {
  node: <T = AdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdminEdgeSubscription
  extends Promise<AsyncIterator<AdminEdge>>,
    Fragmentable {
  node: <T = AdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdmin {
  count: Int;
}

export interface AggregateAdminPromise
  extends Promise<AggregateAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdminSubscription
  extends Promise<AsyncIterator<AggregateAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Invoice {
  idinvoice: Int;
  date: DateTimeOutput;
  tutorpaid: Boolean;
  studentpaid: Boolean;
}

export interface InvoicePromise extends Promise<Invoice>, Fragmentable {
  idinvoice: () => Promise<Int>;
  session: <T = SessionPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  tutorpaid: () => Promise<Boolean>;
  studentpaid: () => Promise<Boolean>;
  note: <T = NotePromise>() => T;
}

export interface InvoiceSubscription
  extends Promise<AsyncIterator<Invoice>>,
    Fragmentable {
  idinvoice: () => Promise<AsyncIterator<Int>>;
  session: <T = SessionSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  tutorpaid: () => Promise<AsyncIterator<Boolean>>;
  studentpaid: () => Promise<AsyncIterator<Boolean>>;
  note: <T = NoteSubscription>() => T;
}

export interface InvoiceNullablePromise
  extends Promise<Invoice | null>,
    Fragmentable {
  idinvoice: () => Promise<Int>;
  session: <T = SessionPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  tutorpaid: () => Promise<Boolean>;
  studentpaid: () => Promise<Boolean>;
  note: <T = NotePromise>() => T;
}

export interface Session {
  idsession: Int;
  date: DateTimeOutput;
  length: Float;
  location: String;
  studentconfirmed: Boolean;
  tutorconfirmed: Boolean;
  invoiced: Boolean;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  idsession: () => Promise<Int>;
  product: <T = ProductPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  length: () => Promise<Float>;
  location: () => Promise<String>;
  studentconfirmed: () => Promise<Boolean>;
  tutorconfirmed: () => Promise<Boolean>;
  invoiced: () => Promise<Boolean>;
  note: <T = NotePromise>() => T;
  studentnote: <T = NotePromise>() => T;
  tutornote: <T = NotePromise>() => T;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  idsession: () => Promise<AsyncIterator<Int>>;
  product: <T = ProductSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  length: () => Promise<AsyncIterator<Float>>;
  location: () => Promise<AsyncIterator<String>>;
  studentconfirmed: () => Promise<AsyncIterator<Boolean>>;
  tutorconfirmed: () => Promise<AsyncIterator<Boolean>>;
  invoiced: () => Promise<AsyncIterator<Boolean>>;
  note: <T = NoteSubscription>() => T;
  studentnote: <T = NoteSubscription>() => T;
  tutornote: <T = NoteSubscription>() => T;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  idsession: () => Promise<Int>;
  product: <T = ProductPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  length: () => Promise<Float>;
  location: () => Promise<String>;
  studentconfirmed: () => Promise<Boolean>;
  tutorconfirmed: () => Promise<Boolean>;
  invoiced: () => Promise<Boolean>;
  note: <T = NotePromise>() => T;
  studentnote: <T = NotePromise>() => T;
  tutornote: <T = NotePromise>() => T;
}

export interface Product {
  idproduct: Int;
  active: Boolean;
  rate: Float;
  tutorshare: Float;
  subject: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  idproduct: () => Promise<Int>;
  student: <T = StudentPromise>() => T;
  tutor: <T = TutorPromise>() => T;
  active: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  rate: () => Promise<Float>;
  tutorshare: () => Promise<Float>;
  subject: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  idproduct: () => Promise<AsyncIterator<Int>>;
  student: <T = StudentSubscription>() => T;
  tutor: <T = TutorSubscription>() => T;
  active: () => Promise<AsyncIterator<Boolean>>;
  company: <T = CompanySubscription>() => T;
  rate: () => Promise<AsyncIterator<Float>>;
  tutorshare: () => Promise<AsyncIterator<Float>>;
  subject: () => Promise<AsyncIterator<String>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  idproduct: () => Promise<Int>;
  student: <T = StudentPromise>() => T;
  tutor: <T = TutorPromise>() => T;
  active: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  rate: () => Promise<Float>;
  tutorshare: () => Promise<Float>;
  subject: () => Promise<String>;
}

export interface Student {
  idstudent: Int;
  name: String;
  phone: String;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  idstudent: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  idstudent: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface StudentNullablePromise
  extends Promise<Student | null>,
    Fragmentable {
  idstudent: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface Tutor {
  idtutor: Int;
  name: String;
  phone: String;
}

export interface TutorPromise extends Promise<Tutor>, Fragmentable {
  idtutor: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface TutorSubscription
  extends Promise<AsyncIterator<Tutor>>,
    Fragmentable {
  idtutor: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface TutorNullablePromise
  extends Promise<Tutor | null>,
    Fragmentable {
  idtutor: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface Note {
  idnote: Int;
  text: String;
}

export interface NotePromise extends Promise<Note>, Fragmentable {
  idnote: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  text: () => Promise<String>;
}

export interface NoteSubscription
  extends Promise<AsyncIterator<Note>>,
    Fragmentable {
  idnote: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
}

export interface NoteNullablePromise
  extends Promise<Note | null>,
    Fragmentable {
  idnote: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  text: () => Promise<String>;
}

export interface InvoiceConnection {
  pageInfo: PageInfo;
  edges: InvoiceEdge[];
}

export interface InvoiceConnectionPromise
  extends Promise<InvoiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvoiceEdge>>() => T;
  aggregate: <T = AggregateInvoicePromise>() => T;
}

export interface InvoiceConnectionSubscription
  extends Promise<AsyncIterator<InvoiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvoiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvoiceSubscription>() => T;
}

export interface InvoiceEdge {
  node: Invoice;
  cursor: String;
}

export interface InvoiceEdgePromise extends Promise<InvoiceEdge>, Fragmentable {
  node: <T = InvoicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvoiceEdgeSubscription
  extends Promise<AsyncIterator<InvoiceEdge>>,
    Fragmentable {
  node: <T = InvoiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvoice {
  count: Int;
}

export interface AggregateInvoicePromise
  extends Promise<AggregateInvoice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvoiceSubscription
  extends Promise<AsyncIterator<AggregateInvoice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NoteConnection {
  pageInfo: PageInfo;
  edges: NoteEdge[];
}

export interface NoteConnectionPromise
  extends Promise<NoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoteEdge>>() => T;
  aggregate: <T = AggregateNotePromise>() => T;
}

export interface NoteConnectionSubscription
  extends Promise<AsyncIterator<NoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoteSubscription>() => T;
}

export interface NoteEdge {
  node: Note;
  cursor: String;
}

export interface NoteEdgePromise extends Promise<NoteEdge>, Fragmentable {
  node: <T = NotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoteEdgeSubscription
  extends Promise<AsyncIterator<NoteEdge>>,
    Fragmentable {
  node: <T = NoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNote {
  count: Int;
}

export interface AggregateNotePromise
  extends Promise<AggregateNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoteSubscription
  extends Promise<AsyncIterator<AggregateNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Test {
  idtest: Int;
  str?: String;
}

export interface TestPromise extends Promise<Test>, Fragmentable {
  idtest: () => Promise<Int>;
  student: <T = StudentPromise>() => T;
  str: () => Promise<String>;
}

export interface TestSubscription
  extends Promise<AsyncIterator<Test>>,
    Fragmentable {
  idtest: () => Promise<AsyncIterator<Int>>;
  student: <T = StudentSubscription>() => T;
  str: () => Promise<AsyncIterator<String>>;
}

export interface TestNullablePromise
  extends Promise<Test | null>,
    Fragmentable {
  idtest: () => Promise<Int>;
  student: <T = StudentPromise>() => T;
  str: () => Promise<String>;
}

export interface TestConnection {
  pageInfo: PageInfo;
  edges: TestEdge[];
}

export interface TestConnectionPromise
  extends Promise<TestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestEdge>>() => T;
  aggregate: <T = AggregateTestPromise>() => T;
}

export interface TestConnectionSubscription
  extends Promise<AsyncIterator<TestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestSubscription>() => T;
}

export interface TestEdge {
  node: Test;
  cursor: String;
}

export interface TestEdgePromise extends Promise<TestEdge>, Fragmentable {
  node: <T = TestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestEdgeSubscription
  extends Promise<AsyncIterator<TestEdge>>,
    Fragmentable {
  node: <T = TestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTest {
  count: Int;
}

export interface AggregateTestPromise
  extends Promise<AggregateTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestSubscription
  extends Promise<AsyncIterator<AggregateTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TutorConnection {
  pageInfo: PageInfo;
  edges: TutorEdge[];
}

export interface TutorConnectionPromise
  extends Promise<TutorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TutorEdge>>() => T;
  aggregate: <T = AggregateTutorPromise>() => T;
}

export interface TutorConnectionSubscription
  extends Promise<AsyncIterator<TutorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TutorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTutorSubscription>() => T;
}

export interface TutorEdge {
  node: Tutor;
  cursor: String;
}

export interface TutorEdgePromise extends Promise<TutorEdge>, Fragmentable {
  node: <T = TutorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TutorEdgeSubscription
  extends Promise<AsyncIterator<TutorEdge>>,
    Fragmentable {
  node: <T = TutorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTutor {
  count: Int;
}

export interface AggregateTutorPromise
  extends Promise<AggregateTutor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTutorSubscription
  extends Promise<AsyncIterator<AggregateTutor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AdminSubscriptionPayload {
  mutation: MutationType;
  node: Admin;
  updatedFields: String[];
  previousValues: AdminPreviousValues;
}

export interface AdminSubscriptionPayloadPromise
  extends Promise<AdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdminPreviousValuesPromise>() => T;
}

export interface AdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdminPreviousValuesSubscription>() => T;
}

export interface AdminPreviousValues {
  idadmin: Int;
  name: String;
  phone: String;
}

export interface AdminPreviousValuesPromise
  extends Promise<AdminPreviousValues>,
    Fragmentable {
  idadmin: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface AdminPreviousValuesSubscription
  extends Promise<AsyncIterator<AdminPreviousValues>>,
    Fragmentable {
  idadmin: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  idcompany: Int;
  name: String;
  address?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  idcompany: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  idcompany: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface InvoiceSubscriptionPayload {
  mutation: MutationType;
  node: Invoice;
  updatedFields: String[];
  previousValues: InvoicePreviousValues;
}

export interface InvoiceSubscriptionPayloadPromise
  extends Promise<InvoiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvoicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvoicePreviousValuesPromise>() => T;
}

export interface InvoiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvoiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvoiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvoicePreviousValuesSubscription>() => T;
}

export interface InvoicePreviousValues {
  idinvoice: Int;
  date: DateTimeOutput;
  tutorpaid: Boolean;
  studentpaid: Boolean;
}

export interface InvoicePreviousValuesPromise
  extends Promise<InvoicePreviousValues>,
    Fragmentable {
  idinvoice: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  tutorpaid: () => Promise<Boolean>;
  studentpaid: () => Promise<Boolean>;
}

export interface InvoicePreviousValuesSubscription
  extends Promise<AsyncIterator<InvoicePreviousValues>>,
    Fragmentable {
  idinvoice: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  tutorpaid: () => Promise<AsyncIterator<Boolean>>;
  studentpaid: () => Promise<AsyncIterator<Boolean>>;
}

export interface NoteSubscriptionPayload {
  mutation: MutationType;
  node: Note;
  updatedFields: String[];
  previousValues: NotePreviousValues;
}

export interface NoteSubscriptionPayloadPromise
  extends Promise<NoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotePreviousValuesPromise>() => T;
}

export interface NoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotePreviousValuesSubscription>() => T;
}

export interface NotePreviousValues {
  idnote: Int;
  text: String;
}

export interface NotePreviousValuesPromise
  extends Promise<NotePreviousValues>,
    Fragmentable {
  idnote: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface NotePreviousValuesSubscription
  extends Promise<AsyncIterator<NotePreviousValues>>,
    Fragmentable {
  idnote: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  idproduct: Int;
  active: Boolean;
  rate: Float;
  tutorshare: Float;
  subject: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  idproduct: () => Promise<Int>;
  active: () => Promise<Boolean>;
  rate: () => Promise<Float>;
  tutorshare: () => Promise<Float>;
  subject: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  idproduct: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  rate: () => Promise<AsyncIterator<Float>>;
  tutorshare: () => Promise<AsyncIterator<Float>>;
  subject: () => Promise<AsyncIterator<String>>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface SessionPreviousValues {
  idsession: Int;
  date: DateTimeOutput;
  length: Float;
  location: String;
  studentconfirmed: Boolean;
  tutorconfirmed: Boolean;
  invoiced: Boolean;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  idsession: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  length: () => Promise<Float>;
  location: () => Promise<String>;
  studentconfirmed: () => Promise<Boolean>;
  tutorconfirmed: () => Promise<Boolean>;
  invoiced: () => Promise<Boolean>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  idsession: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  length: () => Promise<AsyncIterator<Float>>;
  location: () => Promise<AsyncIterator<String>>;
  studentconfirmed: () => Promise<AsyncIterator<Boolean>>;
  tutorconfirmed: () => Promise<AsyncIterator<Boolean>>;
  invoiced: () => Promise<AsyncIterator<Boolean>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  idstudent: Int;
  name: String;
  phone: String;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  idstudent: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  idstudent: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface TestSubscriptionPayload {
  mutation: MutationType;
  node: Test;
  updatedFields: String[];
  previousValues: TestPreviousValues;
}

export interface TestSubscriptionPayloadPromise
  extends Promise<TestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestPreviousValuesPromise>() => T;
}

export interface TestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestPreviousValuesSubscription>() => T;
}

export interface TestPreviousValues {
  idtest: Int;
  str?: String;
}

export interface TestPreviousValuesPromise
  extends Promise<TestPreviousValues>,
    Fragmentable {
  idtest: () => Promise<Int>;
  str: () => Promise<String>;
}

export interface TestPreviousValuesSubscription
  extends Promise<AsyncIterator<TestPreviousValues>>,
    Fragmentable {
  idtest: () => Promise<AsyncIterator<Int>>;
  str: () => Promise<AsyncIterator<String>>;
}

export interface TutorSubscriptionPayload {
  mutation: MutationType;
  node: Tutor;
  updatedFields: String[];
  previousValues: TutorPreviousValues;
}

export interface TutorSubscriptionPayloadPromise
  extends Promise<TutorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TutorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TutorPreviousValuesPromise>() => T;
}

export interface TutorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TutorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TutorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TutorPreviousValuesSubscription>() => T;
}

export interface TutorPreviousValues {
  idtutor: Int;
  name: String;
  phone: String;
}

export interface TutorPreviousValuesPromise
  extends Promise<TutorPreviousValues>,
    Fragmentable {
  idtutor: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface TutorPreviousValuesSubscription
  extends Promise<AsyncIterator<TutorPreviousValues>>,
    Fragmentable {
  idtutor: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  iduser: Int;
  email: String;
  role: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  iduser: () => Promise<Int>;
  email: () => Promise<String>;
  role: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  iduser: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Company",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "Tutor",
    embedded: false
  },
  {
    name: "Admin",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "Invoice",
    embedded: false
  },
  {
    name: "Note",
    embedded: false
  },
  {
    name: "Test",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
