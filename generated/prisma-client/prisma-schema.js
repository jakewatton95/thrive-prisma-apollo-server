module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Admin {
  idadmin: Int!
  name: String!
  phone: String!
  user: User!
}

type AdminConnection {
  pageInfo: PageInfo!
  edges: [AdminEdge]!
  aggregate: AggregateAdmin!
}

input AdminCreateInput {
  idadmin: Int
  name: String!
  phone: String!
  user: UserCreateOneInput!
}

type AdminEdge {
  node: Admin!
  cursor: String!
}

enum AdminOrderByInput {
  idadmin_ASC
  idadmin_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
}

type AdminPreviousValues {
  idadmin: Int!
  name: String!
  phone: String!
}

type AdminSubscriptionPayload {
  mutation: MutationType!
  node: Admin
  updatedFields: [String!]
  previousValues: AdminPreviousValues
}

input AdminSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdminWhereInput
  AND: [AdminSubscriptionWhereInput!]
  OR: [AdminSubscriptionWhereInput!]
  NOT: [AdminSubscriptionWhereInput!]
}

input AdminUpdateInput {
  name: String
  phone: String
  user: UserUpdateOneRequiredInput
}

input AdminUpdateManyMutationInput {
  name: String
  phone: String
}

input AdminWhereInput {
  idadmin: Int
  idadmin_not: Int
  idadmin_in: [Int!]
  idadmin_not_in: [Int!]
  idadmin_lt: Int
  idadmin_lte: Int
  idadmin_gt: Int
  idadmin_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  user: UserWhereInput
  AND: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  NOT: [AdminWhereInput!]
}

input AdminWhereUniqueInput {
  idadmin: Int
}

type AggregateAdmin {
  count: Int!
}

type AggregateCompany {
  count: Int!
}

type AggregateInvoice {
  count: Int!
}

type AggregateNote {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type AggregateTest {
  count: Int!
}

type AggregateTutor {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Company {
  idcompany: Int!
  name: String!
  address: String
}

type CompanyConnection {
  pageInfo: PageInfo!
  edges: [CompanyEdge]!
  aggregate: AggregateCompany!
}

input CompanyCreateInput {
  idcompany: Int
  name: String!
  address: String
}

input CompanyCreateOneInput {
  create: CompanyCreateInput
  connect: CompanyWhereUniqueInput
}

type CompanyEdge {
  node: Company!
  cursor: String!
}

enum CompanyOrderByInput {
  idcompany_ASC
  idcompany_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
}

type CompanyPreviousValues {
  idcompany: Int!
  name: String!
  address: String
}

type CompanySubscriptionPayload {
  mutation: MutationType!
  node: Company
  updatedFields: [String!]
  previousValues: CompanyPreviousValues
}

input CompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyWhereInput
  AND: [CompanySubscriptionWhereInput!]
  OR: [CompanySubscriptionWhereInput!]
  NOT: [CompanySubscriptionWhereInput!]
}

input CompanyUpdateDataInput {
  name: String
  address: String
}

input CompanyUpdateInput {
  name: String
  address: String
}

input CompanyUpdateManyMutationInput {
  name: String
  address: String
}

input CompanyUpdateOneRequiredInput {
  create: CompanyCreateInput
  update: CompanyUpdateDataInput
  upsert: CompanyUpsertNestedInput
  connect: CompanyWhereUniqueInput
}

input CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput!
  create: CompanyCreateInput!
}

input CompanyWhereInput {
  idcompany: Int
  idcompany_not: Int
  idcompany_in: [Int!]
  idcompany_not_in: [Int!]
  idcompany_lt: Int
  idcompany_lte: Int
  idcompany_gt: Int
  idcompany_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  idcompany: Int
}

scalar DateTime

type Invoice {
  idinvoice: Int!
  session: Session!
  date: DateTime!
  tutorpaid: Boolean!
  studentpaid: Boolean!
  note: Note
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge]!
  aggregate: AggregateInvoice!
}

input InvoiceCreateInput {
  idinvoice: Int
  session: SessionCreateOneInput!
  tutorpaid: Boolean
  studentpaid: Boolean
  note: NoteCreateOneInput
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

enum InvoiceOrderByInput {
  idinvoice_ASC
  idinvoice_DESC
  date_ASC
  date_DESC
  tutorpaid_ASC
  tutorpaid_DESC
  studentpaid_ASC
  studentpaid_DESC
}

type InvoicePreviousValues {
  idinvoice: Int!
  date: DateTime!
  tutorpaid: Boolean!
  studentpaid: Boolean!
}

type InvoiceSubscriptionPayload {
  mutation: MutationType!
  node: Invoice
  updatedFields: [String!]
  previousValues: InvoicePreviousValues
}

input InvoiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvoiceWhereInput
  AND: [InvoiceSubscriptionWhereInput!]
  OR: [InvoiceSubscriptionWhereInput!]
  NOT: [InvoiceSubscriptionWhereInput!]
}

input InvoiceUpdateInput {
  session: SessionUpdateOneRequiredInput
  tutorpaid: Boolean
  studentpaid: Boolean
  note: NoteUpdateOneInput
}

input InvoiceUpdateManyMutationInput {
  tutorpaid: Boolean
  studentpaid: Boolean
}

input InvoiceWhereInput {
  idinvoice: Int
  idinvoice_not: Int
  idinvoice_in: [Int!]
  idinvoice_not_in: [Int!]
  idinvoice_lt: Int
  idinvoice_lte: Int
  idinvoice_gt: Int
  idinvoice_gte: Int
  session: SessionWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  tutorpaid: Boolean
  tutorpaid_not: Boolean
  studentpaid: Boolean
  studentpaid_not: Boolean
  note: NoteWhereInput
  AND: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  NOT: [InvoiceWhereInput!]
}

input InvoiceWhereUniqueInput {
  idinvoice: Int
}

scalar Long

type Mutation {
  createAdmin(data: AdminCreateInput!): Admin!
  updateAdmin(data: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin
  updateManyAdmins(data: AdminUpdateManyMutationInput!, where: AdminWhereInput): BatchPayload!
  upsertAdmin(where: AdminWhereUniqueInput!, create: AdminCreateInput!, update: AdminUpdateInput!): Admin!
  deleteAdmin(where: AdminWhereUniqueInput!): Admin
  deleteManyAdmins(where: AdminWhereInput): BatchPayload!
  createCompany(data: CompanyCreateInput!): Company!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateManyCompanies(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): BatchPayload!
  upsertCompany(where: CompanyWhereUniqueInput!, create: CompanyCreateInput!, update: CompanyUpdateInput!): Company!
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
  createInvoice(data: InvoiceCreateInput!): Invoice!
  updateInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateManyInvoices(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): BatchPayload!
  upsertInvoice(where: InvoiceWhereUniqueInput!, create: InvoiceCreateInput!, update: InvoiceUpdateInput!): Invoice!
  deleteInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteManyInvoices(where: InvoiceWhereInput): BatchPayload!
  createNote(data: NoteCreateInput!): Note!
  updateNote(data: NoteUpdateInput!, where: NoteWhereUniqueInput!): Note
  updateManyNotes(data: NoteUpdateManyMutationInput!, where: NoteWhereInput): BatchPayload!
  upsertNote(where: NoteWhereUniqueInput!, create: NoteCreateInput!, update: NoteUpdateInput!): Note!
  deleteNote(where: NoteWhereUniqueInput!): Note
  deleteManyNotes(where: NoteWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  createTest(data: TestCreateInput!): Test!
  updateTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
  updateManyTests(data: TestUpdateManyMutationInput!, where: TestWhereInput): BatchPayload!
  upsertTest(where: TestWhereUniqueInput!, create: TestCreateInput!, update: TestUpdateInput!): Test!
  deleteTest(where: TestWhereUniqueInput!): Test
  deleteManyTests(where: TestWhereInput): BatchPayload!
  createTutor(data: TutorCreateInput!): Tutor!
  updateTutor(data: TutorUpdateInput!, where: TutorWhereUniqueInput!): Tutor
  updateManyTutors(data: TutorUpdateManyMutationInput!, where: TutorWhereInput): BatchPayload!
  upsertTutor(where: TutorWhereUniqueInput!, create: TutorCreateInput!, update: TutorUpdateInput!): Tutor!
  deleteTutor(where: TutorWhereUniqueInput!): Tutor
  deleteManyTutors(where: TutorWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Note {
  idnote: Int!
  user: User!
  text: String!
}

type NoteConnection {
  pageInfo: PageInfo!
  edges: [NoteEdge]!
  aggregate: AggregateNote!
}

input NoteCreateInput {
  idnote: Int
  user: UserCreateOneInput!
  text: String!
}

input NoteCreateOneInput {
  create: NoteCreateInput
  connect: NoteWhereUniqueInput
}

type NoteEdge {
  node: Note!
  cursor: String!
}

enum NoteOrderByInput {
  idnote_ASC
  idnote_DESC
  text_ASC
  text_DESC
}

type NotePreviousValues {
  idnote: Int!
  text: String!
}

type NoteSubscriptionPayload {
  mutation: MutationType!
  node: Note
  updatedFields: [String!]
  previousValues: NotePreviousValues
}

input NoteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NoteWhereInput
  AND: [NoteSubscriptionWhereInput!]
  OR: [NoteSubscriptionWhereInput!]
  NOT: [NoteSubscriptionWhereInput!]
}

input NoteUpdateDataInput {
  user: UserUpdateOneRequiredInput
  text: String
}

input NoteUpdateInput {
  user: UserUpdateOneRequiredInput
  text: String
}

input NoteUpdateManyMutationInput {
  text: String
}

input NoteUpdateOneInput {
  create: NoteCreateInput
  update: NoteUpdateDataInput
  upsert: NoteUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: NoteWhereUniqueInput
}

input NoteUpsertNestedInput {
  update: NoteUpdateDataInput!
  create: NoteCreateInput!
}

input NoteWhereInput {
  idnote: Int
  idnote_not: Int
  idnote_in: [Int!]
  idnote_not_in: [Int!]
  idnote_lt: Int
  idnote_lte: Int
  idnote_gt: Int
  idnote_gte: Int
  user: UserWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  NOT: [NoteWhereInput!]
}

input NoteWhereUniqueInput {
  idnote: Int
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  idproduct: Int!
  student: Student!
  tutor: Tutor!
  active: Boolean!
  company: Company!
  rate: Float!
  tutorshare: Float!
  subject: String!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  idproduct: Int
  student: StudentCreateOneInput!
  tutor: TutorCreateOneInput!
  active: Boolean
  company: CompanyCreateOneInput!
  rate: Float!
  tutorshare: Float!
  subject: String!
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  idproduct_ASC
  idproduct_DESC
  active_ASC
  active_DESC
  rate_ASC
  rate_DESC
  tutorshare_ASC
  tutorshare_DESC
  subject_ASC
  subject_DESC
}

type ProductPreviousValues {
  idproduct: Int!
  active: Boolean!
  rate: Float!
  tutorshare: Float!
  subject: String!
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  student: StudentUpdateOneRequiredInput
  tutor: TutorUpdateOneRequiredInput
  active: Boolean
  company: CompanyUpdateOneRequiredInput
  rate: Float
  tutorshare: Float
  subject: String
}

input ProductUpdateInput {
  student: StudentUpdateOneRequiredInput
  tutor: TutorUpdateOneRequiredInput
  active: Boolean
  company: CompanyUpdateOneRequiredInput
  rate: Float
  tutorshare: Float
  subject: String
}

input ProductUpdateManyMutationInput {
  active: Boolean
  rate: Float
  tutorshare: Float
  subject: String
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  idproduct: Int
  idproduct_not: Int
  idproduct_in: [Int!]
  idproduct_not_in: [Int!]
  idproduct_lt: Int
  idproduct_lte: Int
  idproduct_gt: Int
  idproduct_gte: Int
  student: StudentWhereInput
  tutor: TutorWhereInput
  active: Boolean
  active_not: Boolean
  company: CompanyWhereInput
  rate: Float
  rate_not: Float
  rate_in: [Float!]
  rate_not_in: [Float!]
  rate_lt: Float
  rate_lte: Float
  rate_gt: Float
  rate_gte: Float
  tutorshare: Float
  tutorshare_not: Float
  tutorshare_in: [Float!]
  tutorshare_not_in: [Float!]
  tutorshare_lt: Float
  tutorshare_lte: Float
  tutorshare_gt: Float
  tutorshare_gte: Float
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  idproduct: Int
}

type Query {
  admin(where: AdminWhereUniqueInput!): Admin
  admins(where: AdminWhereInput, orderBy: AdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Admin]!
  adminsConnection(where: AdminWhereInput, orderBy: AdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdminConnection!
  company(where: CompanyWhereUniqueInput!): Company
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company]!
  companiesConnection(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyConnection!
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice]!
  invoicesConnection(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvoiceConnection!
  note(where: NoteWhereUniqueInput!): Note
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note]!
  notesConnection(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NoteConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  test(where: TestWhereUniqueInput!): Test
  tests(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Test]!
  testsConnection(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TestConnection!
  tutor(where: TutorWhereUniqueInput!): Tutor
  tutors(where: TutorWhereInput, orderBy: TutorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tutor]!
  tutorsConnection(where: TutorWhereInput, orderBy: TutorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TutorConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Session {
  idsession: Int!
  product: Product!
  date: DateTime!
  length: Float!
  location: String!
  studentconfirmed: Boolean!
  tutorconfirmed: Boolean!
  invoiced: Boolean!
  note: Note
  studentnote: Note
  tutornote: Note
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  idsession: Int
  product: ProductCreateOneInput!
  date: DateTime!
  length: Float!
  location: String!
  studentconfirmed: Boolean
  tutorconfirmed: Boolean
  invoiced: Boolean
  note: NoteCreateOneInput
  studentnote: NoteCreateOneInput
  tutornote: NoteCreateOneInput
}

input SessionCreateOneInput {
  create: SessionCreateInput
  connect: SessionWhereUniqueInput
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  idsession_ASC
  idsession_DESC
  date_ASC
  date_DESC
  length_ASC
  length_DESC
  location_ASC
  location_DESC
  studentconfirmed_ASC
  studentconfirmed_DESC
  tutorconfirmed_ASC
  tutorconfirmed_DESC
  invoiced_ASC
  invoiced_DESC
}

type SessionPreviousValues {
  idsession: Int!
  date: DateTime!
  length: Float!
  location: String!
  studentconfirmed: Boolean!
  tutorconfirmed: Boolean!
  invoiced: Boolean!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateDataInput {
  product: ProductUpdateOneRequiredInput
  date: DateTime
  length: Float
  location: String
  studentconfirmed: Boolean
  tutorconfirmed: Boolean
  invoiced: Boolean
  note: NoteUpdateOneInput
  studentnote: NoteUpdateOneInput
  tutornote: NoteUpdateOneInput
}

input SessionUpdateInput {
  product: ProductUpdateOneRequiredInput
  date: DateTime
  length: Float
  location: String
  studentconfirmed: Boolean
  tutorconfirmed: Boolean
  invoiced: Boolean
  note: NoteUpdateOneInput
  studentnote: NoteUpdateOneInput
  tutornote: NoteUpdateOneInput
}

input SessionUpdateManyMutationInput {
  date: DateTime
  length: Float
  location: String
  studentconfirmed: Boolean
  tutorconfirmed: Boolean
  invoiced: Boolean
}

input SessionUpdateOneRequiredInput {
  create: SessionCreateInput
  update: SessionUpdateDataInput
  upsert: SessionUpsertNestedInput
  connect: SessionWhereUniqueInput
}

input SessionUpsertNestedInput {
  update: SessionUpdateDataInput!
  create: SessionCreateInput!
}

input SessionWhereInput {
  idsession: Int
  idsession_not: Int
  idsession_in: [Int!]
  idsession_not_in: [Int!]
  idsession_lt: Int
  idsession_lte: Int
  idsession_gt: Int
  idsession_gte: Int
  product: ProductWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  length: Float
  length_not: Float
  length_in: [Float!]
  length_not_in: [Float!]
  length_lt: Float
  length_lte: Float
  length_gt: Float
  length_gte: Float
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  studentconfirmed: Boolean
  studentconfirmed_not: Boolean
  tutorconfirmed: Boolean
  tutorconfirmed_not: Boolean
  invoiced: Boolean
  invoiced_not: Boolean
  note: NoteWhereInput
  studentnote: NoteWhereInput
  tutornote: NoteWhereInput
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  idsession: Int
}

type Student {
  idstudent: Int!
  name: String!
  phone: String!
  user: User!
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  idstudent: Int
  name: String!
  phone: String!
  user: UserCreateOneInput!
}

input StudentCreateOneInput {
  create: StudentCreateInput
  connect: StudentWhereUniqueInput
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  idstudent_ASC
  idstudent_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
}

type StudentPreviousValues {
  idstudent: Int!
  name: String!
  phone: String!
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateDataInput {
  name: String
  phone: String
  user: UserUpdateOneRequiredInput
}

input StudentUpdateInput {
  name: String
  phone: String
  user: UserUpdateOneRequiredInput
}

input StudentUpdateManyMutationInput {
  name: String
  phone: String
}

input StudentUpdateOneRequiredInput {
  create: StudentCreateInput
  update: StudentUpdateDataInput
  upsert: StudentUpsertNestedInput
  connect: StudentWhereUniqueInput
}

input StudentUpsertNestedInput {
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentWhereInput {
  idstudent: Int
  idstudent_not: Int
  idstudent_in: [Int!]
  idstudent_not_in: [Int!]
  idstudent_lt: Int
  idstudent_lte: Int
  idstudent_gt: Int
  idstudent_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  user: UserWhereInput
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  idstudent: Int
}

type Subscription {
  admin(where: AdminSubscriptionWhereInput): AdminSubscriptionPayload
  company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
  invoice(where: InvoiceSubscriptionWhereInput): InvoiceSubscriptionPayload
  note(where: NoteSubscriptionWhereInput): NoteSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
  test(where: TestSubscriptionWhereInput): TestSubscriptionPayload
  tutor(where: TutorSubscriptionWhereInput): TutorSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Test {
  idtest: Int!
  student: Student!
  str: String
}

type TestConnection {
  pageInfo: PageInfo!
  edges: [TestEdge]!
  aggregate: AggregateTest!
}

input TestCreateInput {
  idtest: Int
  student: StudentCreateOneInput!
  str: String
}

type TestEdge {
  node: Test!
  cursor: String!
}

enum TestOrderByInput {
  idtest_ASC
  idtest_DESC
  str_ASC
  str_DESC
}

type TestPreviousValues {
  idtest: Int!
  str: String
}

type TestSubscriptionPayload {
  mutation: MutationType!
  node: Test
  updatedFields: [String!]
  previousValues: TestPreviousValues
}

input TestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TestWhereInput
  AND: [TestSubscriptionWhereInput!]
  OR: [TestSubscriptionWhereInput!]
  NOT: [TestSubscriptionWhereInput!]
}

input TestUpdateInput {
  student: StudentUpdateOneRequiredInput
  str: String
}

input TestUpdateManyMutationInput {
  str: String
}

input TestWhereInput {
  idtest: Int
  idtest_not: Int
  idtest_in: [Int!]
  idtest_not_in: [Int!]
  idtest_lt: Int
  idtest_lte: Int
  idtest_gt: Int
  idtest_gte: Int
  student: StudentWhereInput
  str: String
  str_not: String
  str_in: [String!]
  str_not_in: [String!]
  str_lt: String
  str_lte: String
  str_gt: String
  str_gte: String
  str_contains: String
  str_not_contains: String
  str_starts_with: String
  str_not_starts_with: String
  str_ends_with: String
  str_not_ends_with: String
  AND: [TestWhereInput!]
  OR: [TestWhereInput!]
  NOT: [TestWhereInput!]
}

input TestWhereUniqueInput {
  idtest: Int
}

type Tutor {
  idtutor: Int!
  name: String!
  phone: String!
  user: User!
}

type TutorConnection {
  pageInfo: PageInfo!
  edges: [TutorEdge]!
  aggregate: AggregateTutor!
}

input TutorCreateInput {
  idtutor: Int
  name: String!
  phone: String!
  user: UserCreateOneInput!
}

input TutorCreateOneInput {
  create: TutorCreateInput
  connect: TutorWhereUniqueInput
}

type TutorEdge {
  node: Tutor!
  cursor: String!
}

enum TutorOrderByInput {
  idtutor_ASC
  idtutor_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
}

type TutorPreviousValues {
  idtutor: Int!
  name: String!
  phone: String!
}

type TutorSubscriptionPayload {
  mutation: MutationType!
  node: Tutor
  updatedFields: [String!]
  previousValues: TutorPreviousValues
}

input TutorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TutorWhereInput
  AND: [TutorSubscriptionWhereInput!]
  OR: [TutorSubscriptionWhereInput!]
  NOT: [TutorSubscriptionWhereInput!]
}

input TutorUpdateDataInput {
  name: String
  phone: String
  user: UserUpdateOneRequiredInput
}

input TutorUpdateInput {
  name: String
  phone: String
  user: UserUpdateOneRequiredInput
}

input TutorUpdateManyMutationInput {
  name: String
  phone: String
}

input TutorUpdateOneRequiredInput {
  create: TutorCreateInput
  update: TutorUpdateDataInput
  upsert: TutorUpsertNestedInput
  connect: TutorWhereUniqueInput
}

input TutorUpsertNestedInput {
  update: TutorUpdateDataInput!
  create: TutorCreateInput!
}

input TutorWhereInput {
  idtutor: Int
  idtutor_not: Int
  idtutor_in: [Int!]
  idtutor_not_in: [Int!]
  idtutor_lt: Int
  idtutor_lte: Int
  idtutor_gt: Int
  idtutor_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  user: UserWhereInput
  AND: [TutorWhereInput!]
  OR: [TutorWhereInput!]
  NOT: [TutorWhereInput!]
}

input TutorWhereUniqueInput {
  idtutor: Int
}

type User {
  iduser: Int!
  company: Company!
  email: String!
  role: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  iduser: Int
  company: CompanyCreateOneInput!
  email: String!
  role: String!
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  iduser_ASC
  iduser_DESC
  email_ASC
  email_DESC
  role_ASC
  role_DESC
}

type UserPreviousValues {
  iduser: Int!
  email: String!
  role: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  company: CompanyUpdateOneRequiredInput
  email: String
  role: String
}

input UserUpdateInput {
  company: CompanyUpdateOneRequiredInput
  email: String
  role: String
}

input UserUpdateManyMutationInput {
  email: String
  role: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  iduser: Int
  iduser_not: Int
  iduser_in: [Int!]
  iduser_not_in: [Int!]
  iduser_lt: Int
  iduser_lte: Int
  iduser_gt: Int
  iduser_gte: Int
  company: CompanyWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  role: String
  role_not: String
  role_in: [String!]
  role_not_in: [String!]
  role_lt: String
  role_lte: String
  role_gt: String
  role_gte: String
  role_contains: String
  role_not_contains: String
  role_starts_with: String
  role_not_starts_with: String
  role_ends_with: String
  role_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  iduser: Int
  email: String
}
`
      }
    